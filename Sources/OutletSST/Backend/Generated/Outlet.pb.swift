// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Outlet.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_ConfigEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var val: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetConfig_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configKeyList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetConfig_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configList: [Outlet_Backend_Agent_Grpc_Generated_ConfigEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_PutConfig_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configList: [Outlet_Backend_Agent_Grpc_Generated_ConfigEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_PutConfig_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetIcon_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var iconID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetIcon_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var icon: Outlet_Backend_Agent_Grpc_Generated_Icon {
    get {return _icon ?? Outlet_Backend_Agent_Grpc_Generated_Icon()}
    set {_icon = newValue}
  }
  /// Returns true if `icon` has been explicitly set.
  public var hasIcon: Bool {return self._icon != nil}
  /// Clears the value of `icon`. Subsequent reads from it will return its default value.
  public mutating func clearIcon() {self._icon = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _icon: Outlet_Backend_Agent_Grpc_Generated_Icon? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_Icon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var iconID: UInt32 = 0

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceList: [Outlet_Backend_Agent_Grpc_Generated_Device] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUid: UInt32 = 0

  public var longDeviceID: String = String()

  public var treeType: UInt32 = 0

  public var friendlyName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetFilter_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetFilter_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filterCriteria: Outlet_Backend_Agent_Grpc_Generated_FilterCriteria {
    get {return _filterCriteria ?? Outlet_Backend_Agent_Grpc_Generated_FilterCriteria()}
    set {_filterCriteria = newValue}
  }
  /// Returns true if `filterCriteria` has been explicitly set.
  public var hasFilterCriteria: Bool {return self._filterCriteria != nil}
  /// Clears the value of `filterCriteria`. Subsequent reads from it will return its default value.
  public mutating func clearFilterCriteria() {self._filterCriteria = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filterCriteria: Outlet_Backend_Agent_Grpc_Generated_FilterCriteria? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var filterCriteria: Outlet_Backend_Agent_Grpc_Generated_FilterCriteria {
    get {return _filterCriteria ?? Outlet_Backend_Agent_Grpc_Generated_FilterCriteria()}
    set {_filterCriteria = newValue}
  }
  /// Returns true if `filterCriteria` has been explicitly set.
  public var hasFilterCriteria: Bool {return self._filterCriteria != nil}
  /// Clears the value of `filterCriteria`. Subsequent reads from it will return its default value.
  public mutating func clearFilterCriteria() {self._filterCriteria = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filterCriteria: Outlet_Backend_Agent_Grpc_Generated_FilterCriteria? = nil
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var selectedRowGuidSet: [String] = []

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rowGuid: String = String()

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expandedRowGuidSet: [String] = []

  public var selectedRowGuidSet: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUid: UInt32 = 0

  public var nodeUid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DownloadFromGDrive_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUid: UInt32 = 0

  public var nodeUid: UInt32 = 0

  public var requestorID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userOp: Outlet_Backend_Agent_Grpc_Generated_UserOp {
    get {return _userOp ?? Outlet_Backend_Agent_Grpc_Generated_UserOp()}
    set {_userOp = newValue}
  }
  /// Returns true if `userOp` has been explicitly set.
  public var hasUserOp: Bool {return self._userOp != nil}
  /// Clears the value of `userOp`. Subsequent reads from it will return its default value.
  public mutating func clearUserOp() {self._userOp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userOp: Outlet_Backend_Agent_Grpc_Generated_UserOp? = nil
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_Subscribe_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_GetOpExecPlayState_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GenerateMergeTree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeIDLeft: String = String()

  public var treeIDRight: String = String()

  public var changeListLeft: [String] = []

  public var changeListRight: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DragDrop_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var srcTreeID: String = String()

  public var dstTreeID: String = String()

  public var srcGuidList: [String] = []

  public var dstGuid: String = String()

  public var isInto: Bool = false

  public var dragOperation: UInt32 = 0

  public var dirConflictPolicy: UInt32 = 0

  public var fileConflictPolicy: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_RefreshSubtree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentifier: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _nodeIdentifier ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_nodeIdentifier = newValue}
  }
  /// Returns true if `nodeIdentifier` has been explicitly set.
  public var hasNodeIdentifier: Bool {return self._nodeIdentifier != nil}
  /// Clears the value of `nodeIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentifier() {self._nodeIdentifier = nil}

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeIdentifier: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_DeleteSubtree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceUid: UInt32 = 0

  public var nodeUidList: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: String = String()

  public var secondaryMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// required
  public var feMsg: String = String()

  /// optional
  public var feSecondaryMsg: String = String()

  /// optional
  public var beMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_UidContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeIDLeft: String = String()

  public var treeIDRight: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeIDLeft: String = String()

  public var treeIDRight: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DragDrop_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isAccepted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DirMetaGuidUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guid: String = String()

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return self._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {self._dirMeta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_DirMetaUidUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return self._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {self._dirMeta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
}

/// StatsUpdate is sent:
/// 1. Some period of time after node added / modified / removed from tree (not after *every* update)
/// 2. If the FE requests it (DEPRECATED behavior)
public struct Outlet_Backend_Agent_Grpc_Generated_StatsUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dirMetaByGuidList: [Outlet_Backend_Agent_Grpc_Generated_DirMetaGuidUpdate] = []

  public var dirMetaByUidList: [Outlet_Backend_Agent_Grpc_Generated_DirMetaUidUpdate] = []

  public var statusMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var loadStateInt: UInt32 = 0

  public var statsUpdate: Outlet_Backend_Agent_Grpc_Generated_StatsUpdate {
    get {return _statsUpdate ?? Outlet_Backend_Agent_Grpc_Generated_StatsUpdate()}
    set {_statsUpdate = newValue}
  }
  /// Returns true if `statsUpdate` has been explicitly set.
  public var hasStatsUpdate: Bool {return self._statsUpdate != nil}
  /// Clears the value of `statsUpdate`. Subsequent reads from it will return its default value.
  public mutating func clearStatsUpdate() {self._statsUpdate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _statsUpdate: Outlet_Backend_Agent_Grpc_Generated_StatsUpdate? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subtreeRootSpid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _subtreeRootSpid ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_subtreeRootSpid = newValue}
  }
  /// Returns true if `subtreeRootSpid` has been explicitly set.
  public var hasSubtreeRootSpid: Bool {return self._subtreeRootSpid != nil}
  /// Clears the value of `subtreeRootSpid`. Subsequent reads from it will return its default value.
  public mutating func clearSubtreeRootSpid() {self._subtreeRootSpid = nil}

  public var upsertedSnList: [Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair] = []

  public var removedSnList: [Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subtreeRootSpid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_BatchFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchUid: UInt32 = 0

  public var msg: String = String()

  public var secondaryMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchUid: UInt32 = 0

  public var errorHandlingStrategy: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GUIDSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guidSet: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_SignalMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sigInt: UInt32 = 0

  public var sender: String = String()

  public var signalData: Outlet_Backend_Agent_Grpc_Generated_SignalMsg.OneOf_SignalData? = nil

  public var empty: Outlet_Backend_Agent_Grpc_Generated_Empty {
    get {
      if case .empty(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_Empty()
    }
    set {signalData = .empty(newValue)}
  }

  public var errorOccurred: Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred {
    get {
      if case .errorOccurred(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred()
    }
    set {signalData = .errorOccurred(newValue)}
  }

  public var displayTreeUiState: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState {
    get {
      if case .displayTreeUiState(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState()
    }
    set {signalData = .displayTreeUiState(newValue)}
  }

  public var playState: Outlet_Backend_Agent_Grpc_Generated_PlayState {
    get {
      if case .playState(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_PlayState()
    }
    set {signalData = .playState(newValue)}
  }

  public var uiEnablement: Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement {
    get {
      if case .uiEnablement(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement()
    }
    set {signalData = .uiEnablement(newValue)}
  }

  /// for NODE_UPSERTED, NODE_REMOVED
  public var sn: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair {
    get {
      if case .sn(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair()
    }
    set {signalData = .sn(newValue)}
  }

  /// for TREE_LOAD_STATE_UPDATED
  public var treeLoadUpdate: Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate {
    get {
      if case .treeLoadUpdate(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate()
    }
    set {signalData = .treeLoadUpdate(newValue)}
  }

  public var downloadMsg: Outlet_Backend_Agent_Grpc_Generated_DownloadMsg {
    get {
      if case .downloadMsg(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_DownloadMsg()
    }
    set {signalData = .downloadMsg(newValue)}
  }

  public var statsUpdate: Outlet_Backend_Agent_Grpc_Generated_StatsUpdate {
    get {
      if case .statsUpdate(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_StatsUpdate()
    }
    set {signalData = .statsUpdate(newValue)}
  }

  public var device: Outlet_Backend_Agent_Grpc_Generated_Device {
    get {
      if case .device(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_Device()
    }
    set {signalData = .device(newValue)}
  }

  public var dualDisplayTree: Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree {
    get {
      if case .dualDisplayTree(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree()
    }
    set {signalData = .dualDisplayTree(newValue)}
  }

  /// for SUBTREE_NODES_CHANGED
  public var subtree: Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData {
    get {
      if case .subtree(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData()
    }
    set {signalData = .subtree(newValue)}
  }

  /// for BATCH_FAILED
  public var batchFailed: Outlet_Backend_Agent_Grpc_Generated_BatchFailed {
    get {
      if case .batchFailed(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_BatchFailed()
    }
    set {signalData = .batchFailed(newValue)}
  }

  /// for HANDLE_BATCH_FAILED
  public var handleBatchFailed: Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed {
    get {
      if case .handleBatchFailed(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed()
    }
    set {signalData = .handleBatchFailed(newValue)}
  }

  /// for SET_SELECTED_ROWS
  public var guidSet: Outlet_Backend_Agent_Grpc_Generated_GUIDSet {
    get {
      if case .guidSet(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_GUIDSet()
    }
    set {signalData = .guidSet(newValue)}
  }

  public var treeActionRequest: Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request {
    get {
      if case .treeActionRequest(let v)? = signalData {return v}
      return Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request()
    }
    set {signalData = .treeActionRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SignalData: Equatable {
    case empty(Outlet_Backend_Agent_Grpc_Generated_Empty)
    case errorOccurred(Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred)
    case displayTreeUiState(Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState)
    case playState(Outlet_Backend_Agent_Grpc_Generated_PlayState)
    case uiEnablement(Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement)
    /// for NODE_UPSERTED, NODE_REMOVED
    case sn(Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair)
    /// for TREE_LOAD_STATE_UPDATED
    case treeLoadUpdate(Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate)
    case downloadMsg(Outlet_Backend_Agent_Grpc_Generated_DownloadMsg)
    case statsUpdate(Outlet_Backend_Agent_Grpc_Generated_StatsUpdate)
    case device(Outlet_Backend_Agent_Grpc_Generated_Device)
    case dualDisplayTree(Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree)
    /// for SUBTREE_NODES_CHANGED
    case subtree(Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData)
    /// for BATCH_FAILED
    case batchFailed(Outlet_Backend_Agent_Grpc_Generated_BatchFailed)
    /// for HANDLE_BATCH_FAILED
    case handleBatchFailed(Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed)
    /// for SET_SELECTED_ROWS
    case guidSet(Outlet_Backend_Agent_Grpc_Generated_GUIDSet)
    case treeActionRequest(Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request)

  #if !swift(>=4.1)
    public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SignalMsg.OneOf_SignalData, rhs: Outlet_Backend_Agent_Grpc_Generated_SignalMsg.OneOf_SignalData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorOccurred, .errorOccurred): return {
        guard case .errorOccurred(let l) = lhs, case .errorOccurred(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.displayTreeUiState, .displayTreeUiState): return {
        guard case .displayTreeUiState(let l) = lhs, case .displayTreeUiState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playState, .playState): return {
        guard case .playState(let l) = lhs, case .playState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiEnablement, .uiEnablement): return {
        guard case .uiEnablement(let l) = lhs, case .uiEnablement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sn, .sn): return {
        guard case .sn(let l) = lhs, case .sn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.treeLoadUpdate, .treeLoadUpdate): return {
        guard case .treeLoadUpdate(let l) = lhs, case .treeLoadUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downloadMsg, .downloadMsg): return {
        guard case .downloadMsg(let l) = lhs, case .downloadMsg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statsUpdate, .statsUpdate): return {
        guard case .statsUpdate(let l) = lhs, case .statsUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.device, .device): return {
        guard case .device(let l) = lhs, case .device(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dualDisplayTree, .dualDisplayTree): return {
        guard case .dualDisplayTree(let l) = lhs, case .dualDisplayTree(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subtree, .subtree): return {
        guard case .subtree(let l) = lhs, case .subtree(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batchFailed, .batchFailed): return {
        guard case .batchFailed(let l) = lhs, case .batchFailed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.handleBatchFailed, .handleBatchFailed): return {
        guard case .handleBatchFailed(let l) = lhs, case .handleBatchFailed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guidSet, .guidSet): return {
        guard case .guidSet(let l) = lhs, case .guidSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.treeActionRequest, .treeActionRequest): return {
        guard case .treeActionRequest(let l) = lhs, case .treeActionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leftTree: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState {
    get {return _storage._leftTree ?? Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState()}
    set {_uniqueStorage()._leftTree = newValue}
  }
  /// Returns true if `leftTree` has been explicitly set.
  public var hasLeftTree: Bool {return _storage._leftTree != nil}
  /// Clears the value of `leftTree`. Subsequent reads from it will return its default value.
  public mutating func clearLeftTree() {_uniqueStorage()._leftTree = nil}

  public var rightTree: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState {
    get {return _storage._rightTree ?? Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState()}
    set {_uniqueStorage()._rightTree = newValue}
  }
  /// Returns true if `rightTree` has been explicitly set.
  public var hasRightTree: Bool {return _storage._rightTree != nil}
  /// Clears the value of `rightTree`. Subsequent reads from it will return its default value.
  public mutating func clearRightTree() {_uniqueStorage()._rightTree = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Outlet_Backend_Agent_Grpc_Generated_DownloadMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filename: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_SendSignalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetChildList_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentSpid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _parentSpid ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_parentSpid = newValue}
  }
  /// Returns true if `parentSpid` has been explicitly set.
  public var hasParentSpid: Bool {return self._parentSpid != nil}
  /// Clears the value of `parentSpid`. Subsequent reads from it will return its default value.
  public mutating func clearParentSpid() {self._parentSpid = nil}

  public var treeID: String = String()

  public var isExpandingParent: Bool = false

  /// 0=unlimited
  public var maxResults: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parentSpid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetChildList_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var childList: [Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair] = []

  /// if this exists, then ignore all else
  public var error: Outlet_Backend_Agent_Grpc_Generated_Error {
    get {return _error ?? Outlet_Backend_Agent_Grpc_Generated_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Outlet_Backend_Agent_Grpc_Generated_Error? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _spid ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_spid = newValue}
  }
  /// Returns true if `spid` has been explicitly set.
  public var hasSpid: Bool {return self._spid != nil}
  /// Clears the value of `spid`. Subsequent reads from it will return its default value.
  public mutating func clearSpid() {self._spid = nil}

  public var stopAtPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ancestorList: [Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_PlayState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var targetGuidList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var menuItemList: [Outlet_Backend_Agent_Grpc_Generated_TreeContextMenuItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_TreeContextMenuItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemType: UInt32 = 0

  public var title: String = String()

  public var actionID: UInt32 = 0

  /// Optional. Only used for menu items which apply to a subset, but not the entirety, of the selected nodes:
  public var targetGuidList: [String] = []

  public var submenuItemList: [Outlet_Backend_Agent_Grpc_Generated_TreeContextMenuItem] = []

  /// context depends on the action_uid; not used for most actions
  public var targetUid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_TreeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var actionID: UInt32 = 0

  /// only required for certain actions
  public var targetGuidList: [String] = []

  /// only required for certain actions
  public var targetNodeList: [Outlet_Backend_Agent_Grpc_Generated_TNode] = []

  /// context depends on the action_uid; not used for most actions
  public var targetUid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionList: [Outlet_Backend_Agent_Grpc_Generated_TreeAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var rootSn: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair {
    get {return _rootSn ?? Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair()}
    set {_rootSn = newValue}
  }
  /// Returns true if `rootSn` has been explicitly set.
  public var hasRootSn: Bool {return self._rootSn != nil}
  /// Clears the value of `rootSn`. Subsequent reads from it will return its default value.
  public mutating func clearRootSn() {self._rootSn = nil}

  public var rootExists: Bool = false

  public var offendingPath: String = String()

  public var needsManualLoad: Bool = false

  public var treeDisplayMode: UInt32 = 0

  public var hasCheckboxes_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rootSn: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isStartup: Bool = false

  public var treeID: String = String()

  public var returnAsync: Bool = false

  public var userPath: String = String()

  public var deviceUid: UInt32 = 0

  public var spid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _spid ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_spid = newValue}
  }
  /// Returns true if `spid` has been explicitly set.
  public var hasSpid: Bool {return self._spid != nil}
  /// Clears the value of `spid`. Subsequent reads from it will return its default value.
  public mutating func clearSpid() {self._spid = nil}

  public var treeDisplayMode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayTreeUiState: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState {
    get {return _displayTreeUiState ?? Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState()}
    set {_displayTreeUiState = newValue}
  }
  /// Returns true if `displayTreeUiState` has been explicitly set.
  public var hasDisplayTreeUiState: Bool {return self._displayTreeUiState != nil}
  /// Clears the value of `displayTreeUiState`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayTreeUiState() {self._displayTreeUiState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _displayTreeUiState: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_SingleNode_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var node: Outlet_Backend_Agent_Grpc_Generated_TNode {
    get {return _node ?? Outlet_Backend_Agent_Grpc_Generated_TNode()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {self._node = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _node: Outlet_Backend_Agent_Grpc_Generated_TNode? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fullPath: String = String()

  public var uidSuggestion: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeUid: UInt32 = 0

  public var deviceUid: UInt32 = 0

  public var fullPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sn: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair {
    get {return _sn ?? Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair()}
    set {_sn = newValue}
  }
  /// Returns true if `sn` has been explicitly set.
  public var hasSn: Bool {return self._sn != nil}
  /// Clears the value of `sn`. Subsequent reads from it will return its default value.
  public mutating func clearSn() {self._sn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sn: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetNodeForUid_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  /// optional (but encouraged!)
  public var deviceUid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "outlet.backend.agent.grpc.generated"

extension Outlet_Backend_Agent_Grpc_Generated_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_Empty, rhs: Outlet_Backend_Agent_Grpc_Generated_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_ConfigEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_ConfigEntry, rhs: Outlet_Backend_Agent_Grpc_Generated_ConfigEntry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetConfig_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfig_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_key_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.configKeyList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configKeyList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.configKeyList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetConfig_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetConfig_Request) -> Bool {
    if lhs.configKeyList != rhs.configKeyList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetConfig_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfig_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetConfig_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetConfig_Response) -> Bool {
    if lhs.configList != rhs.configList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_PutConfig_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutConfig_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_PutConfig_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_PutConfig_Request) -> Bool {
    if lhs.configList != rhs.configList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_PutConfig_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutConfig_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_PutConfig_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_PutConfig_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetIcon_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIcon_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "icon_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.iconID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.iconID != 0 {
      try visitor.visitSingularUInt32Field(value: self.iconID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetIcon_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetIcon_Request) -> Bool {
    if lhs.iconID != rhs.iconID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetIcon_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIcon_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "icon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._icon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._icon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetIcon_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetIcon_Response) -> Bool {
    if lhs._icon != rhs._icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_Icon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Icon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "icon_id"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.iconID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.iconID != 0 {
      try visitor.visitSingularUInt32Field(value: self.iconID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_Icon, rhs: Outlet_Backend_Agent_Grpc_Generated_Icon) -> Bool {
    if lhs.iconID != rhs.iconID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeviceList_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeviceList_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deviceList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetDeviceList_Response) -> Bool {
    if lhs.deviceList != rhs.deviceList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uid"),
    2: .standard(proto: "long_device_id"),
    3: .standard(proto: "tree_type"),
    4: .standard(proto: "friendly_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longDeviceID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.treeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.friendlyName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 1)
    }
    if !self.longDeviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.longDeviceID, fieldNumber: 2)
    }
    if self.treeType != 0 {
      try visitor.visitSingularUInt32Field(value: self.treeType, fieldNumber: 3)
    }
    if !self.friendlyName.isEmpty {
      try visitor.visitSingularStringField(value: self.friendlyName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_Device, rhs: Outlet_Backend_Agent_Grpc_Generated_Device) -> Bool {
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.longDeviceID != rhs.longDeviceID {return false}
    if lhs.treeType != rhs.treeType {return false}
    if lhs.friendlyName != rhs.friendlyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetFilter_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFilter_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetFilter_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetFilter_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetFilter_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFilter_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_criteria"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filterCriteria) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filterCriteria {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetFilter_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetFilter_Response) -> Bool {
    if lhs._filterCriteria != rhs._filterCriteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFilter_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
    2: .standard(proto: "filter_criteria"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filterCriteria) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try { if let v = self._filterCriteria {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs._filterCriteria != rhs._filterCriteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFilter_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_UpdateFilter_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSelectedRowSet_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "selected_row_guid_set"),
    2: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.selectedRowGuidSet) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.selectedRowGuidSet.isEmpty {
      try visitor.visitRepeatedStringField(value: self.selectedRowGuidSet, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Request) -> Bool {
    if lhs.selectedRowGuidSet != rhs.selectedRowGuidSet {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSelectedRowSet_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_SetSelectedRowSet_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveExpandedRow_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_guid"),
    2: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rowGuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowGuid.isEmpty {
      try visitor.visitSingularStringField(value: self.rowGuid, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Request) -> Bool {
    if lhs.rowGuid != rhs.rowGuid {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveExpandedRow_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_RemoveExpandedRow_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRowsOfInterest_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRowsOfInterest_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expanded_row_guid_set"),
    2: .standard(proto: "selected_row_guid_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.expandedRowGuidSet) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.selectedRowGuidSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expandedRowGuidSet.isEmpty {
      try visitor.visitRepeatedStringField(value: self.expandedRowGuidSet, fieldNumber: 1)
    }
    if !self.selectedRowGuidSet.isEmpty {
      try visitor.visitRepeatedStringField(value: self.selectedRowGuidSet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetRowsOfInterest_Response) -> Bool {
    if lhs.expandedRowGuidSet != rhs.expandedRowGuidSet {return false}
    if lhs.selectedRowGuidSet != rhs.selectedRowGuidSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPendingOp_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uid"),
    2: .standard(proto: "node_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 1)
    }
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Request) -> Bool {
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DownloadFromGDrive_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadFromGDrive_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uid"),
    2: .standard(proto: "node_uid"),
    3: .standard(proto: "requestor_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestorID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 1)
    }
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 2)
    }
    if !self.requestorID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestorID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DownloadFromGDrive_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_DownloadFromGDrive_Request) -> Bool {
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.requestorID != rhs.requestorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPendingOp_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_op"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userOp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userOp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetLastPendingOp_Response) -> Bool {
    if lhs._userOp != rhs._userOp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_Subscribe_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subscribe_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_Subscribe_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_Subscribe_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetOpExecPlayState_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOpExecPlayState_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetOpExecPlayState_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetOpExecPlayState_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToggleUiEnablement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement, rhs: Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GenerateMergeTree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateMergeTree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id_left"),
    2: .standard(proto: "tree_id_right"),
    3: .standard(proto: "change_list_left"),
    4: .standard(proto: "change_list_right"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeIDLeft) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeIDRight) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.changeListLeft) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.changeListRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeIDLeft.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDLeft, fieldNumber: 1)
    }
    if !self.treeIDRight.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDRight, fieldNumber: 2)
    }
    if !self.changeListLeft.isEmpty {
      try visitor.visitRepeatedStringField(value: self.changeListLeft, fieldNumber: 3)
    }
    if !self.changeListRight.isEmpty {
      try visitor.visitRepeatedStringField(value: self.changeListRight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GenerateMergeTree_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GenerateMergeTree_Request) -> Bool {
    if lhs.treeIDLeft != rhs.treeIDLeft {return false}
    if lhs.treeIDRight != rhs.treeIDRight {return false}
    if lhs.changeListLeft != rhs.changeListLeft {return false}
    if lhs.changeListRight != rhs.changeListRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DragDrop_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DragDrop_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_tree_id"),
    2: .standard(proto: "dst_tree_id"),
    3: .standard(proto: "src_guid_list"),
    4: .standard(proto: "dst_guid"),
    5: .standard(proto: "is_into"),
    6: .standard(proto: "drag_operation"),
    7: .standard(proto: "dir_conflict_policy"),
    8: .standard(proto: "file_conflict_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcTreeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstTreeID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.srcGuidList) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dstGuid) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isInto) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.dragOperation) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.dirConflictPolicy) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.fileConflictPolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcTreeID.isEmpty {
      try visitor.visitSingularStringField(value: self.srcTreeID, fieldNumber: 1)
    }
    if !self.dstTreeID.isEmpty {
      try visitor.visitSingularStringField(value: self.dstTreeID, fieldNumber: 2)
    }
    if !self.srcGuidList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.srcGuidList, fieldNumber: 3)
    }
    if !self.dstGuid.isEmpty {
      try visitor.visitSingularStringField(value: self.dstGuid, fieldNumber: 4)
    }
    if self.isInto != false {
      try visitor.visitSingularBoolField(value: self.isInto, fieldNumber: 5)
    }
    if self.dragOperation != 0 {
      try visitor.visitSingularUInt32Field(value: self.dragOperation, fieldNumber: 6)
    }
    if self.dirConflictPolicy != 0 {
      try visitor.visitSingularUInt32Field(value: self.dirConflictPolicy, fieldNumber: 7)
    }
    if self.fileConflictPolicy != 0 {
      try visitor.visitSingularUInt32Field(value: self.fileConflictPolicy, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DragDrop_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_DragDrop_Request) -> Bool {
    if lhs.srcTreeID != rhs.srcTreeID {return false}
    if lhs.dstTreeID != rhs.dstTreeID {return false}
    if lhs.srcGuidList != rhs.srcGuidList {return false}
    if lhs.dstGuid != rhs.dstGuid {return false}
    if lhs.isInto != rhs.isInto {return false}
    if lhs.dragOperation != rhs.dragOperation {return false}
    if lhs.dirConflictPolicy != rhs.dirConflictPolicy {return false}
    if lhs.fileConflictPolicy != rhs.fileConflictPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_RefreshSubtree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshSubtree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identifier"),
    2: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_RefreshSubtree_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_RefreshSubtree_Request) -> Bool {
    if lhs._nodeIdentifier != rhs._nodeIdentifier {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DeleteSubtree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteSubtree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uid"),
    2: .standard(proto: "node_uid_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.nodeUidList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 1)
    }
    if !self.nodeUidList.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.nodeUidList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DeleteSubtree_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_DeleteSubtree_Request) -> Bool {
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.nodeUidList != rhs.nodeUidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorOccurred"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .standard(proto: "secondary_msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secondaryMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    if !self.secondaryMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.secondaryMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred, rhs: Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.secondaryMsg != rhs.secondaryMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fe_msg"),
    2: .standard(proto: "fe_secondary_msg"),
    3: .standard(proto: "be_msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.feMsg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feSecondaryMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.beMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.feMsg, fieldNumber: 1)
    }
    if !self.feSecondaryMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.feSecondaryMsg, fieldNumber: 2)
    }
    if !self.beMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.beMsg, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_Error, rhs: Outlet_Backend_Agent_Grpc_Generated_Error) -> Bool {
    if lhs.feMsg != rhs.feMsg {return false}
    if lhs.feSecondaryMsg != rhs.feSecondaryMsg {return false}
    if lhs.beMsg != rhs.beMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_UidContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UidContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_UidContainer, rhs: Outlet_Backend_Agent_Grpc_Generated_UidContainer) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartDiffTrees_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id_left"),
    2: .standard(proto: "tree_id_right"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeIDLeft) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeIDRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeIDLeft.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDLeft, fieldNumber: 1)
    }
    if !self.treeIDRight.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDRight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Request) -> Bool {
    if lhs.treeIDLeft != rhs.treeIDLeft {return false}
    if lhs.treeIDRight != rhs.treeIDRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartDiffTrees_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id_left"),
    2: .standard(proto: "tree_id_right"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeIDLeft) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeIDRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeIDLeft.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDLeft, fieldNumber: 1)
    }
    if !self.treeIDRight.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDRight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_StartDiffTrees_Response) -> Bool {
    if lhs.treeIDLeft != rhs.treeIDLeft {return false}
    if lhs.treeIDRight != rhs.treeIDRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DragDrop_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DragDrop_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_accepted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isAccepted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isAccepted != false {
      try visitor.visitSingularBoolField(value: self.isAccepted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DragDrop_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_DragDrop_Response) -> Bool {
    if lhs.isAccepted != rhs.isAccepted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DirMetaGuidUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirMetaGuidUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guid"),
    2: .standard(proto: "dir_meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.guid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dirMeta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    try { if let v = self._dirMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DirMetaGuidUpdate, rhs: Outlet_Backend_Agent_Grpc_Generated_DirMetaGuidUpdate) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs._dirMeta != rhs._dirMeta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DirMetaUidUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirMetaUidUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "dir_meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dirMeta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try { if let v = self._dirMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DirMetaUidUpdate, rhs: Outlet_Backend_Agent_Grpc_Generated_DirMetaUidUpdate) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs._dirMeta != rhs._dirMeta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_StatsUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatsUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dir_meta_by_guid_list"),
    2: .standard(proto: "dir_meta_by_uid_list"),
    3: .standard(proto: "status_msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dirMetaByGuidList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dirMetaByUidList) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.statusMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dirMetaByGuidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dirMetaByGuidList, fieldNumber: 1)
    }
    if !self.dirMetaByUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dirMetaByUidList, fieldNumber: 2)
    }
    if !self.statusMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMsg, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_StatsUpdate, rhs: Outlet_Backend_Agent_Grpc_Generated_StatsUpdate) -> Bool {
    if lhs.dirMetaByGuidList != rhs.dirMetaByGuidList {return false}
    if lhs.dirMetaByUidList != rhs.dirMetaByUidList {return false}
    if lhs.statusMsg != rhs.statusMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TreeLoadUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "load_state_int"),
    2: .standard(proto: "stats_update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.loadStateInt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._statsUpdate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.loadStateInt != 0 {
      try visitor.visitSingularUInt32Field(value: self.loadStateInt, fieldNumber: 1)
    }
    try { if let v = self._statsUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate, rhs: Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate) -> Bool {
    if lhs.loadStateInt != rhs.loadStateInt {return false}
    if lhs._statsUpdate != rhs._statsUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubtreeChangeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subtree_root_spid"),
    2: .standard(proto: "upserted_sn_list"),
    3: .standard(proto: "removed_sn_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subtreeRootSpid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.upsertedSnList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.removedSnList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subtreeRootSpid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.upsertedSnList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.upsertedSnList, fieldNumber: 2)
    }
    if !self.removedSnList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedSnList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData, rhs: Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData) -> Bool {
    if lhs._subtreeRootSpid != rhs._subtreeRootSpid {return false}
    if lhs.upsertedSnList != rhs.upsertedSnList {return false}
    if lhs.removedSnList != rhs.removedSnList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_BatchFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchFailed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_uid"),
    2: .same(proto: "msg"),
    3: .standard(proto: "secondary_msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.batchUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.secondaryMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.batchUid, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if !self.secondaryMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.secondaryMsg, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_BatchFailed, rhs: Outlet_Backend_Agent_Grpc_Generated_BatchFailed) -> Bool {
    if lhs.batchUid != rhs.batchUid {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.secondaryMsg != rhs.secondaryMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HandleBatchFailed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_uid"),
    2: .standard(proto: "error_handling_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.batchUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.errorHandlingStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.batchUid, fieldNumber: 1)
    }
    if self.errorHandlingStrategy != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorHandlingStrategy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed, rhs: Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed) -> Bool {
    if lhs.batchUid != rhs.batchUid {return false}
    if lhs.errorHandlingStrategy != rhs.errorHandlingStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GUIDSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GUIDSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guid_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.guidSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guidSet.isEmpty {
      try visitor.visitRepeatedStringField(value: self.guidSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GUIDSet, rhs: Outlet_Backend_Agent_Grpc_Generated_GUIDSet) -> Bool {
    if lhs.guidSet != rhs.guidSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SignalMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sig_int"),
    2: .same(proto: "sender"),
    10: .same(proto: "empty"),
    11: .standard(proto: "error_occurred"),
    12: .standard(proto: "display_tree_ui_state"),
    13: .standard(proto: "play_state"),
    14: .standard(proto: "ui_enablement"),
    15: .same(proto: "sn"),
    17: .standard(proto: "tree_load_update"),
    18: .standard(proto: "download_msg"),
    19: .standard(proto: "stats_update"),
    20: .same(proto: "device"),
    21: .standard(proto: "dual_display_tree"),
    22: .same(proto: "subtree"),
    23: .standard(proto: "batch_failed"),
    24: .standard(proto: "handle_batch_failed"),
    25: .standard(proto: "guid_set"),
    26: .standard(proto: "tree_action_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sigInt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 10: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_Empty?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .empty(v)
        }
      }()
      case 11: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_ErrorOccurred?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .errorOccurred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .errorOccurred(v)
        }
      }()
      case 12: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .displayTreeUiState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .displayTreeUiState(v)
        }
      }()
      case 13: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_PlayState?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .playState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .playState(v)
        }
      }()
      case 14: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_ToggleUiEnablement?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .uiEnablement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .uiEnablement(v)
        }
      }()
      case 15: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .sn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .sn(v)
        }
      }()
      case 17: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_TreeLoadUpdate?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .treeLoadUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .treeLoadUpdate(v)
        }
      }()
      case 18: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_DownloadMsg?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .downloadMsg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .downloadMsg(v)
        }
      }()
      case 19: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_StatsUpdate?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .statsUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .statsUpdate(v)
        }
      }()
      case 20: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_Device?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .device(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .device(v)
        }
      }()
      case 21: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .dualDisplayTree(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .dualDisplayTree(v)
        }
      }()
      case 22: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_SubtreeChangeData?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .subtree(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .subtree(v)
        }
      }()
      case 23: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_BatchFailed?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .batchFailed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .batchFailed(v)
        }
      }()
      case 24: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_HandleBatchFailed?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .handleBatchFailed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .handleBatchFailed(v)
        }
      }()
      case 25: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_GUIDSet?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .guidSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .guidSet(v)
        }
      }()
      case 26: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request?
        var hadOneofValue = false
        if let current = self.signalData {
          hadOneofValue = true
          if case .treeActionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signalData = .treeActionRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.sigInt != 0 {
      try visitor.visitSingularUInt32Field(value: self.sigInt, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    switch self.signalData {
    case .empty?: try {
      guard case .empty(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .errorOccurred?: try {
      guard case .errorOccurred(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .displayTreeUiState?: try {
      guard case .displayTreeUiState(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .playState?: try {
      guard case .playState(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .uiEnablement?: try {
      guard case .uiEnablement(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .sn?: try {
      guard case .sn(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .treeLoadUpdate?: try {
      guard case .treeLoadUpdate(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .downloadMsg?: try {
      guard case .downloadMsg(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .statsUpdate?: try {
      guard case .statsUpdate(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .device?: try {
      guard case .device(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .dualDisplayTree?: try {
      guard case .dualDisplayTree(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .subtree?: try {
      guard case .subtree(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .batchFailed?: try {
      guard case .batchFailed(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .handleBatchFailed?: try {
      guard case .handleBatchFailed(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .guidSet?: try {
      guard case .guidSet(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .treeActionRequest?: try {
      guard case .treeActionRequest(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SignalMsg, rhs: Outlet_Backend_Agent_Grpc_Generated_SignalMsg) -> Bool {
    if lhs.sigInt != rhs.sigInt {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.signalData != rhs.signalData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DualDisplayTree"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "left_tree"),
    2: .standard(proto: "right_tree"),
  ]

  fileprivate class _StorageClass {
    var _leftTree: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState? = nil
    var _rightTree: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leftTree = source._leftTree
      _rightTree = source._rightTree
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._leftTree) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rightTree) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._leftTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rightTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree, rhs: Outlet_Backend_Agent_Grpc_Generated_DualDisplayTree) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._leftTree != rhs_storage._leftTree {return false}
        if _storage._rightTree != rhs_storage._rightTree {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DownloadMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DownloadMsg, rhs: Outlet_Backend_Agent_Grpc_Generated_DownloadMsg) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SendSignalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendSignalResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SendSignalResponse, rhs: Outlet_Backend_Agent_Grpc_Generated_SendSignalResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetChildList_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChildList_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_spid"),
    2: .standard(proto: "tree_id"),
    3: .standard(proto: "is_expanding_parent"),
    4: .standard(proto: "max_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentSpid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isExpandingParent) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxResults) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentSpid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    if self.isExpandingParent != false {
      try visitor.visitSingularBoolField(value: self.isExpandingParent, fieldNumber: 3)
    }
    if self.maxResults != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxResults, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetChildList_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetChildList_Request) -> Bool {
    if lhs._parentSpid != rhs._parentSpid {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.isExpandingParent != rhs.isExpandingParent {return false}
    if lhs.maxResults != rhs.maxResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetChildList_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChildList_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_list"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.childList) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.childList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childList, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetChildList_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetChildList_Response) -> Bool {
    if lhs.childList != rhs.childList {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAncestorList_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spid"),
    2: .standard(proto: "stop_at_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stopAtPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stopAtPath.isEmpty {
      try visitor.visitSingularStringField(value: self.stopAtPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Request) -> Bool {
    if lhs._spid != rhs._spid {return false}
    if lhs.stopAtPath != rhs.stopAtPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAncestorList_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ancestor_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ancestorList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ancestorList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ancestorList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetAncestorList_Response) -> Bool {
    if lhs.ancestorList != rhs.ancestorList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_PlayState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_PlayState, rhs: Outlet_Backend_Agent_Grpc_Generated_PlayState) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartSubtreeLoad_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartSubtreeLoad_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_StartSubtreeLoad_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetContextMenu_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
    2: .standard(proto: "target_guid_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.targetGuidList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    if !self.targetGuidList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetGuidList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.targetGuidList != rhs.targetGuidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetContextMenu_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "menu_item_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.menuItemList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.menuItemList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.menuItemList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetContextMenu_Response) -> Bool {
    if lhs.menuItemList != rhs.menuItemList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_TreeContextMenuItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TreeContextMenuItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "title"),
    3: .standard(proto: "action_id"),
    4: .standard(proto: "target_guid_list"),
    5: .standard(proto: "submenu_item_list"),
    6: .standard(proto: "target_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.targetGuidList) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.submenuItemList) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.targetUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemType != 0 {
      try visitor.visitSingularUInt32Field(value: self.itemType, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 3)
    }
    if !self.targetGuidList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetGuidList, fieldNumber: 4)
    }
    if !self.submenuItemList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.submenuItemList, fieldNumber: 5)
    }
    if self.targetUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_TreeContextMenuItem, rhs: Outlet_Backend_Agent_Grpc_Generated_TreeContextMenuItem) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs.title != rhs.title {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.targetGuidList != rhs.targetGuidList {return false}
    if lhs.submenuItemList != rhs.submenuItemList {return false}
    if lhs.targetUid != rhs.targetUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_TreeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TreeAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
    2: .standard(proto: "action_id"),
    3: .standard(proto: "target_guid_list"),
    4: .standard(proto: "target_node_list"),
    5: .standard(proto: "target_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.actionID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.targetGuidList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.targetNodeList) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.targetUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    if self.actionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionID, fieldNumber: 2)
    }
    if !self.targetGuidList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetGuidList, fieldNumber: 3)
    }
    if !self.targetNodeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targetNodeList, fieldNumber: 4)
    }
    if self.targetUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetUid, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_TreeAction, rhs: Outlet_Backend_Agent_Grpc_Generated_TreeAction) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.targetGuidList != rhs.targetGuidList {return false}
    if lhs.targetNodeList != rhs.targetNodeList {return false}
    if lhs.targetUid != rhs.targetUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteTreeActionList_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actionList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Request) -> Bool {
    if lhs.actionList != rhs.actionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteTreeActionList_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_ExecuteTreeActionList_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayTreeUiState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
    2: .standard(proto: "root_sn"),
    3: .standard(proto: "root_exists"),
    4: .standard(proto: "offending_path"),
    5: .standard(proto: "needs_manual_load"),
    6: .standard(proto: "tree_display_mode"),
    7: .standard(proto: "has_checkboxes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rootSn) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.rootExists) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.offendingPath) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.needsManualLoad) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.treeDisplayMode) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasCheckboxes_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try { if let v = self._rootSn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.rootExists != false {
      try visitor.visitSingularBoolField(value: self.rootExists, fieldNumber: 3)
    }
    if !self.offendingPath.isEmpty {
      try visitor.visitSingularStringField(value: self.offendingPath, fieldNumber: 4)
    }
    if self.needsManualLoad != false {
      try visitor.visitSingularBoolField(value: self.needsManualLoad, fieldNumber: 5)
    }
    if self.treeDisplayMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.treeDisplayMode, fieldNumber: 6)
    }
    if self.hasCheckboxes_p != false {
      try visitor.visitSingularBoolField(value: self.hasCheckboxes_p, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState, rhs: Outlet_Backend_Agent_Grpc_Generated_DisplayTreeUiState) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs._rootSn != rhs._rootSn {return false}
    if lhs.rootExists != rhs.rootExists {return false}
    if lhs.offendingPath != rhs.offendingPath {return false}
    if lhs.needsManualLoad != rhs.needsManualLoad {return false}
    if lhs.treeDisplayMode != rhs.treeDisplayMode {return false}
    if lhs.hasCheckboxes_p != rhs.hasCheckboxes_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestDisplayTree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_startup"),
    2: .standard(proto: "tree_id"),
    3: .standard(proto: "return_async"),
    4: .standard(proto: "user_path"),
    5: .standard(proto: "device_uid"),
    6: .same(proto: "spid"),
    7: .standard(proto: "tree_display_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isStartup) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.returnAsync) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userPath) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._spid) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.treeDisplayMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isStartup != false {
      try visitor.visitSingularBoolField(value: self.isStartup, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    if self.returnAsync != false {
      try visitor.visitSingularBoolField(value: self.returnAsync, fieldNumber: 3)
    }
    if !self.userPath.isEmpty {
      try visitor.visitSingularStringField(value: self.userPath, fieldNumber: 4)
    }
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 5)
    }
    try { if let v = self._spid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.treeDisplayMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.treeDisplayMode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Request) -> Bool {
    if lhs.isStartup != rhs.isStartup {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.returnAsync != rhs.returnAsync {return false}
    if lhs.userPath != rhs.userPath {return false}
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs._spid != rhs._spid {return false}
    if lhs.treeDisplayMode != rhs.treeDisplayMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestDisplayTree_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_tree_ui_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._displayTreeUiState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayTreeUiState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_RequestDisplayTree_Response) -> Bool {
    if lhs._displayTreeUiState != rhs._displayTreeUiState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SingleNode_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleNode_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SingleNode_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_SingleNode_Response) -> Bool {
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUidForLocalPath_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_path"),
    2: .standard(proto: "uid_suggestion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.uidSuggestion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 1)
    }
    if self.uidSuggestion != 0 {
      try visitor.visitSingularUInt32Field(value: self.uidSuggestion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Request) -> Bool {
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.uidSuggestion != rhs.uidSuggestion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUidForLocalPath_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetUidForLocalPath_Response) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSnFor_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_uid"),
    2: .standard(proto: "device_uid"),
    3: .standard(proto: "full_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 1)
    }
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 2)
    }
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Request) -> Bool {
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSnFor_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sn"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetSnFor_Response) -> Bool {
    if lhs._sn != rhs._sn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetNodeForUid_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodeForUid_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "device_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetNodeForUid_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetNodeForUid_Request) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextUid_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Request, rhs: Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextUid_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Response, rhs: Outlet_Backend_Agent_Grpc_Generated_GetNextUid_Response) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
