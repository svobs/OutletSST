// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Node.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// nothing
public struct Outlet_Backend_Agent_Grpc_Generated_Null {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_UserOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var opUid: UInt32 = 0

  public var batchUid: UInt32 = 0

  public var opType: UInt32 = 0

  public var srcNode: Outlet_Backend_Agent_Grpc_Generated_TNode {
    get {return _srcNode ?? Outlet_Backend_Agent_Grpc_Generated_TNode()}
    set {_srcNode = newValue}
  }
  /// Returns true if `srcNode` has been explicitly set.
  public var hasSrcNode: Bool {return self._srcNode != nil}
  /// Clears the value of `srcNode`. Subsequent reads from it will return its default value.
  public mutating func clearSrcNode() {self._srcNode = nil}

  public var dstNode: Outlet_Backend_Agent_Grpc_Generated_TNode {
    get {return _dstNode ?? Outlet_Backend_Agent_Grpc_Generated_TNode()}
    set {_dstNode = newValue}
  }
  /// Returns true if `dstNode` has been explicitly set.
  public var hasDstNode: Bool {return self._dstNode != nil}
  /// Clears the value of `dstNode`. Subsequent reads from it will return its default value.
  public mutating func clearDstNode() {self._dstNode = nil}

  /// no support for result yet
  public var createTs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _srcNode: Outlet_Backend_Agent_Grpc_Generated_TNode? = nil
  fileprivate var _dstNode: Outlet_Backend_Agent_Grpc_Generated_TNode? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_SrcDstNodeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var srcNode: Outlet_Backend_Agent_Grpc_Generated_TNode {
    get {return _srcNode ?? Outlet_Backend_Agent_Grpc_Generated_TNode()}
    set {_srcNode = newValue}
  }
  /// Returns true if `srcNode` has been explicitly set.
  public var hasSrcNode: Bool {return self._srcNode != nil}
  /// Clears the value of `srcNode`. Subsequent reads from it will return its default value.
  public mutating func clearSrcNode() {self._srcNode = nil}

  public var dstNode: Outlet_Backend_Agent_Grpc_Generated_TNode {
    get {return _dstNode ?? Outlet_Backend_Agent_Grpc_Generated_TNode()}
    set {_dstNode = newValue}
  }
  /// Returns true if `dstNode` has been explicitly set.
  public var hasDstNode: Bool {return self._dstNode != nil}
  /// Clears the value of `dstNode`. Subsequent reads from it will return its default value.
  public mutating func clearDstNode() {self._dstNode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _srcNode: Outlet_Backend_Agent_Grpc_Generated_TNode? = nil
  fileprivate var _dstNode: Outlet_Backend_Agent_Grpc_Generated_TNode? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _spid ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_spid = newValue}
  }
  /// Returns true if `spid` has been explicitly set.
  public var hasSpid: Bool {return self._spid != nil}
  /// Clears the value of `spid`. Subsequent reads from it will return its default value.
  public mutating func clearSpid() {self._spid = nil}

  public var node: Outlet_Backend_Agent_Grpc_Generated_TNode {
    get {return _node ?? Outlet_Backend_Agent_Grpc_Generated_TNode()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {self._node = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spid: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
  fileprivate var _node: Outlet_Backend_Agent_Grpc_Generated_TNode? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pathList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only nonzero for SPIDs
  public var pathUid: UInt32 = 0

  public var singlePath: String = String()

  /// Optional. For SPIDs only (needed for: NODE_UPSERTED, NODE_REMOVED, SUBTREE_NODES_CHANGED)
  public var parentGuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates the class of this NodeIdentifier. CategorySPIDs have an entry for each category
  public var identifierType: UInt32 = 0

  public var deviceUid: UInt32 = 0

  public var nodeUid: UInt32 = 0

  public var subtypeMeta: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier.OneOf_SubtypeMeta? = nil

  /// AKA "not a SPID"
  public var multiPathIDMeta: Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta {
    get {
      if case .multiPathIDMeta(let v)? = subtypeMeta {return v}
      return Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta()
    }
    set {subtypeMeta = .multiPathIDMeta(newValue)}
  }

  /// SPIDs
  public var spidMeta: Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta {
    get {
      if case .spidMeta(let v)? = subtypeMeta {return v}
      return Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta()
    }
    set {subtypeMeta = .spidMeta(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SubtypeMeta: Equatable {
    /// AKA "not a SPID"
    case multiPathIDMeta(Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta)
    /// SPIDs
    case spidMeta(Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta)

  #if !swift(>=4.1)
    public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier.OneOf_SubtypeMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier.OneOf_SubtypeMeta) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.multiPathIDMeta, .multiPathIDMeta): return {
        guard case .multiPathIDMeta(let l) = lhs, case .multiPathIDMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spidMeta, .spidMeta): return {
        guard case .spidMeta(let l) = lhs, case .spidMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_TNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentifier: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier {
    get {return _storage._nodeIdentifier ?? Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier()}
    set {_uniqueStorage()._nodeIdentifier = newValue}
  }
  /// Returns true if `nodeIdentifier` has been explicitly set.
  public var hasNodeIdentifier: Bool {return _storage._nodeIdentifier != nil}
  /// Clears the value of `nodeIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentifier() {_uniqueStorage()._nodeIdentifier = nil}

  public var trashed: UInt32 {
    get {return _storage._trashed}
    set {_uniqueStorage()._trashed = newValue}
  }

  public var isShared: Bool {
    get {return _storage._isShared}
    set {_uniqueStorage()._isShared = newValue}
  }

  public var iconID: UInt32 {
    get {return _storage._iconID}
    set {_uniqueStorage()._iconID = newValue}
  }

  public var nodeType: OneOf_NodeType? {
    get {return _storage._nodeType}
    set {_uniqueStorage()._nodeType = newValue}
  }

  public var containerMeta: Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta {
    get {
      if case .containerMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta()
    }
    set {_uniqueStorage()._nodeType = .containerMeta(newValue)}
  }

  public var categoryMeta: Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta {
    get {
      if case .categoryMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta()
    }
    set {_uniqueStorage()._nodeType = .categoryMeta(newValue)}
  }

  public var rootTypeMeta: Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta {
    get {
      if case .rootTypeMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta()
    }
    set {_uniqueStorage()._nodeType = .rootTypeMeta(newValue)}
  }

  public var localDirMeta: Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta {
    get {
      if case .localDirMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta()
    }
    set {_uniqueStorage()._nodeType = .localDirMeta(newValue)}
  }

  public var localFileMeta: Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta {
    get {
      if case .localFileMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta()
    }
    set {_uniqueStorage()._nodeType = .localFileMeta(newValue)}
  }

  public var gdriveFileMeta: Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta {
    get {
      if case .gdriveFileMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta()
    }
    set {_uniqueStorage()._nodeType = .gdriveFileMeta(newValue)}
  }

  public var gdriveFolderMeta: Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta {
    get {
      if case .gdriveFolderMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta()
    }
    set {_uniqueStorage()._nodeType = .gdriveFolderMeta(newValue)}
  }

  public var nonexistentDirMeta: Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta {
    get {
      if case .nonexistentDirMeta(let v)? = _storage._nodeType {return v}
      return Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta()
    }
    set {_uniqueStorage()._nodeType = .nonexistentDirMeta(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NodeType: Equatable {
    case containerMeta(Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta)
    case categoryMeta(Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta)
    case rootTypeMeta(Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta)
    case localDirMeta(Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta)
    case localFileMeta(Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta)
    case gdriveFileMeta(Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta)
    case gdriveFolderMeta(Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta)
    case nonexistentDirMeta(Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta)

  #if !swift(>=4.1)
    public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_TNode.OneOf_NodeType, rhs: Outlet_Backend_Agent_Grpc_Generated_TNode.OneOf_NodeType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.containerMeta, .containerMeta): return {
        guard case .containerMeta(let l) = lhs, case .containerMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.categoryMeta, .categoryMeta): return {
        guard case .categoryMeta(let l) = lhs, case .categoryMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rootTypeMeta, .rootTypeMeta): return {
        guard case .rootTypeMeta(let l) = lhs, case .rootTypeMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localDirMeta, .localDirMeta): return {
        guard case .localDirMeta(let l) = lhs, case .localDirMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localFileMeta, .localFileMeta): return {
        guard case .localFileMeta(let l) = lhs, case .localFileMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gdriveFileMeta, .gdriveFileMeta): return {
        guard case .gdriveFileMeta(let l) = lhs, case .gdriveFileMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gdriveFolderMeta, .gdriveFolderMeta): return {
        guard case .gdriveFolderMeta(let l) = lhs, case .gdriveFolderMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonexistentDirMeta, .nonexistentDirMeta): return {
        guard case .nonexistentDirMeta(let l) = lhs, case .nonexistentDirMeta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Outlet_Backend_Agent_Grpc_Generated_FilterCriteria {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var searchQuery: String = String()

  public var isTrashed: UInt32 = 0

  public var isShared: UInt32 = 0

  public var isIgnoreCase: Bool = false

  public var showSubtreesOfMatches: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_DirMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hasData_p: Bool = false

  public var fileCount: UInt32 = 0

  public var dirCount: UInt32 = 0

  public var trashedFileCount: UInt32 = 0

  public var trashedDirCount: UInt32 = 0

  public var sizeBytes: UInt64 = 0

  public var trashedBytes: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return self._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {self._dirMeta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return self._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {self._dirMeta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return self._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {self._dirMeta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentUid: UInt32 = 0

  public var isLive: Bool = false

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return self._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {self._dirMeta = nil}

  public var allChildrenFetched: Bool = false

  public var syncTs: UInt64 = 0

  public var createTs: UInt64 = 0

  public var modifyTs: UInt64 = 0

  public var changeTs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
}

public struct Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentUid: UInt32 = 0

  public var isLive: Bool = false

  public var sizeBytes: UInt64 = 0

  public var syncTs: UInt64 = 0

  public var createTs: UInt64 = 0

  public var modifyTs: UInt64 = 0

  public var changeTs: UInt64 = 0

  public var md5: String = String()

  public var sha256: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var googID: String = String()

  public var name: String = String()

  public var ownerUid: UInt32 = 0

  public var sharedByUserUid: UInt32 = 0

  public var driveID: String = String()

  public var parentUidList: [UInt32] = []

  public var syncTs: UInt64 = 0

  public var modifyTs: UInt64 = 0

  public var createTs: UInt64 = 0

  public var md5: String = String()

  public var version: UInt32 = 0

  public var sizeBytes: UInt64 = 0

  public var mimeTypeUid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var googID: String {
    get {return _storage._googID}
    set {_uniqueStorage()._googID = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var ownerUid: UInt32 {
    get {return _storage._ownerUid}
    set {_uniqueStorage()._ownerUid = newValue}
  }

  public var sharedByUserUid: UInt32 {
    get {return _storage._sharedByUserUid}
    set {_uniqueStorage()._sharedByUserUid = newValue}
  }

  public var driveID: String {
    get {return _storage._driveID}
    set {_uniqueStorage()._driveID = newValue}
  }

  public var parentUidList: [UInt32] {
    get {return _storage._parentUidList}
    set {_uniqueStorage()._parentUidList = newValue}
  }

  public var syncTs: UInt64 {
    get {return _storage._syncTs}
    set {_uniqueStorage()._syncTs = newValue}
  }

  public var modifyTs: UInt64 {
    get {return _storage._modifyTs}
    set {_uniqueStorage()._modifyTs = newValue}
  }

  public var createTs: UInt64 {
    get {return _storage._createTs}
    set {_uniqueStorage()._createTs = newValue}
  }

  public var dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta {
    get {return _storage._dirMeta ?? Outlet_Backend_Agent_Grpc_Generated_DirMeta()}
    set {_uniqueStorage()._dirMeta = newValue}
  }
  /// Returns true if `dirMeta` has been explicitly set.
  public var hasDirMeta: Bool {return _storage._dirMeta != nil}
  /// Clears the value of `dirMeta`. Subsequent reads from it will return its default value.
  public mutating func clearDirMeta() {_uniqueStorage()._dirMeta = nil}

  public var allChildrenFetched: Bool {
    get {return _storage._allChildrenFetched}
    set {_uniqueStorage()._allChildrenFetched = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "outlet.backend.agent.grpc.generated"

extension Outlet_Backend_Agent_Grpc_Generated_Null: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Null"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_Null, rhs: Outlet_Backend_Agent_Grpc_Generated_Null) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_UserOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserOp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "op_uid"),
    2: .standard(proto: "batch_uid"),
    3: .standard(proto: "op_type"),
    4: .standard(proto: "src_node"),
    5: .standard(proto: "dst_node"),
    6: .standard(proto: "create_ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.opUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.batchUid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.opType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._srcNode) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._dstNode) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.createTs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.opUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.opUid, fieldNumber: 1)
    }
    if self.batchUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.batchUid, fieldNumber: 2)
    }
    if self.opType != 0 {
      try visitor.visitSingularUInt32Field(value: self.opType, fieldNumber: 3)
    }
    try { if let v = self._srcNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dstNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.createTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createTs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_UserOp, rhs: Outlet_Backend_Agent_Grpc_Generated_UserOp) -> Bool {
    if lhs.opUid != rhs.opUid {return false}
    if lhs.batchUid != rhs.batchUid {return false}
    if lhs.opType != rhs.opType {return false}
    if lhs._srcNode != rhs._srcNode {return false}
    if lhs._dstNode != rhs._dstNode {return false}
    if lhs.createTs != rhs.createTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SrcDstNodeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SrcDstNodeList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_node"),
    2: .standard(proto: "dst_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._srcNode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dstNode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._srcNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dstNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SrcDstNodeList, rhs: Outlet_Backend_Agent_Grpc_Generated_SrcDstNodeList) -> Bool {
    if lhs._srcNode != rhs._srcNode {return false}
    if lhs._dstNode != rhs._dstNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SPIDNodePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spid"),
    2: .same(proto: "node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair, rhs: Outlet_Backend_Agent_Grpc_Generated_SPIDNodePair) -> Bool {
    if lhs._spid != rhs._spid {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiPathIdentifierMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "path_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.pathList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pathList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta) -> Bool {
    if lhs.pathList != rhs.pathList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePathIdentifierMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "path_uid"),
    6: .standard(proto: "single_path"),
    7: .standard(proto: "parent_guid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.pathUid) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.singlePath) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.parentGuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.pathUid, fieldNumber: 5)
    }
    if !self.singlePath.isEmpty {
      try visitor.visitSingularStringField(value: self.singlePath, fieldNumber: 6)
    }
    if !self.parentGuid.isEmpty {
      try visitor.visitSingularStringField(value: self.parentGuid, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta) -> Bool {
    if lhs.pathUid != rhs.pathUid {return false}
    if lhs.singlePath != rhs.singlePath {return false}
    if lhs.parentGuid != rhs.parentGuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identifier_type"),
    2: .standard(proto: "device_uid"),
    3: .standard(proto: "node_uid"),
    4: .standard(proto: "multi_path_id_meta"),
    5: .standard(proto: "spid_meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.identifierType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      case 4: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_MultiPathIdentifierMeta?
        var hadOneofValue = false
        if let current = self.subtypeMeta {
          hadOneofValue = true
          if case .multiPathIDMeta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subtypeMeta = .multiPathIDMeta(v)
        }
      }()
      case 5: try {
        var v: Outlet_Backend_Agent_Grpc_Generated_SinglePathIdentifierMeta?
        var hadOneofValue = false
        if let current = self.subtypeMeta {
          hadOneofValue = true
          if case .spidMeta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subtypeMeta = .spidMeta(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.identifierType != 0 {
      try visitor.visitSingularUInt32Field(value: self.identifierType, fieldNumber: 1)
    }
    if self.deviceUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUid, fieldNumber: 2)
    }
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 3)
    }
    switch self.subtypeMeta {
    case .multiPathIDMeta?: try {
      guard case .multiPathIDMeta(let v)? = self.subtypeMeta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .spidMeta?: try {
      guard case .spidMeta(let v)? = self.subtypeMeta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier, rhs: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier) -> Bool {
    if lhs.identifierType != rhs.identifierType {return false}
    if lhs.deviceUid != rhs.deviceUid {return false}
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.subtypeMeta != rhs.subtypeMeta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_TNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identifier"),
    2: .same(proto: "trashed"),
    3: .standard(proto: "is_shared"),
    4: .standard(proto: "icon_id"),
    10: .standard(proto: "container_meta"),
    11: .standard(proto: "category_meta"),
    12: .standard(proto: "root_type_meta"),
    20: .standard(proto: "local_dir_meta"),
    21: .standard(proto: "local_file_meta"),
    22: .standard(proto: "gdrive_file_meta"),
    23: .standard(proto: "gdrive_folder_meta"),
    24: .standard(proto: "nonexistent_dir_meta"),
  ]

  fileprivate class _StorageClass {
    var _nodeIdentifier: Outlet_Backend_Agent_Grpc_Generated_NodeIdentifier? = nil
    var _trashed: UInt32 = 0
    var _isShared: Bool = false
    var _iconID: UInt32 = 0
    var _nodeType: Outlet_Backend_Agent_Grpc_Generated_TNode.OneOf_NodeType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodeIdentifier = source._nodeIdentifier
      _trashed = source._trashed
      _isShared = source._isShared
      _iconID = source._iconID
      _nodeType = source._nodeType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._nodeIdentifier) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._trashed) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isShared) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._iconID) }()
        case 10: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .containerMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .containerMeta(v)
          }
        }()
        case 11: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .categoryMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .categoryMeta(v)
          }
        }()
        case 12: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .rootTypeMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .rootTypeMeta(v)
          }
        }()
        case 20: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .localDirMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .localDirMeta(v)
          }
        }()
        case 21: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .localFileMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .localFileMeta(v)
          }
        }()
        case 22: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .gdriveFileMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .gdriveFileMeta(v)
          }
        }()
        case 23: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .gdriveFolderMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .gdriveFolderMeta(v)
          }
        }()
        case 24: try {
          var v: Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta?
          var hadOneofValue = false
          if let current = _storage._nodeType {
            hadOneofValue = true
            if case .nonexistentDirMeta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._nodeType = .nonexistentDirMeta(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nodeIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._trashed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._trashed, fieldNumber: 2)
      }
      if _storage._isShared != false {
        try visitor.visitSingularBoolField(value: _storage._isShared, fieldNumber: 3)
      }
      if _storage._iconID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._iconID, fieldNumber: 4)
      }
      switch _storage._nodeType {
      case .containerMeta?: try {
        guard case .containerMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .categoryMeta?: try {
        guard case .categoryMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .rootTypeMeta?: try {
        guard case .rootTypeMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .localDirMeta?: try {
        guard case .localDirMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .localFileMeta?: try {
        guard case .localFileMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .gdriveFileMeta?: try {
        guard case .gdriveFileMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .gdriveFolderMeta?: try {
        guard case .gdriveFolderMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .nonexistentDirMeta?: try {
        guard case .nonexistentDirMeta(let v)? = _storage._nodeType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_TNode, rhs: Outlet_Backend_Agent_Grpc_Generated_TNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodeIdentifier != rhs_storage._nodeIdentifier {return false}
        if _storage._trashed != rhs_storage._trashed {return false}
        if _storage._isShared != rhs_storage._isShared {return false}
        if _storage._iconID != rhs_storage._iconID {return false}
        if _storage._nodeType != rhs_storage._nodeType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_FilterCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterCriteria"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_query"),
    2: .standard(proto: "is_trashed"),
    3: .standard(proto: "is_shared"),
    4: .standard(proto: "is_ignore_case"),
    5: .standard(proto: "show_subtrees_of_matches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.searchQuery) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.isTrashed) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.isShared) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isIgnoreCase) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.showSubtreesOfMatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchQuery.isEmpty {
      try visitor.visitSingularStringField(value: self.searchQuery, fieldNumber: 1)
    }
    if self.isTrashed != 0 {
      try visitor.visitSingularUInt32Field(value: self.isTrashed, fieldNumber: 2)
    }
    if self.isShared != 0 {
      try visitor.visitSingularUInt32Field(value: self.isShared, fieldNumber: 3)
    }
    if self.isIgnoreCase != false {
      try visitor.visitSingularBoolField(value: self.isIgnoreCase, fieldNumber: 4)
    }
    if self.showSubtreesOfMatches != false {
      try visitor.visitSingularBoolField(value: self.showSubtreesOfMatches, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_FilterCriteria, rhs: Outlet_Backend_Agent_Grpc_Generated_FilterCriteria) -> Bool {
    if lhs.searchQuery != rhs.searchQuery {return false}
    if lhs.isTrashed != rhs.isTrashed {return false}
    if lhs.isShared != rhs.isShared {return false}
    if lhs.isIgnoreCase != rhs.isIgnoreCase {return false}
    if lhs.showSubtreesOfMatches != rhs.showSubtreesOfMatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_DirMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_data"),
    2: .standard(proto: "file_count"),
    3: .standard(proto: "dir_count"),
    4: .standard(proto: "trashed_file_count"),
    5: .standard(proto: "trashed_dir_count"),
    6: .standard(proto: "size_bytes"),
    7: .standard(proto: "trashed_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasData_p) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.fileCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.dirCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.trashedFileCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.trashedDirCount) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.sizeBytes) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.trashedBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasData_p != false {
      try visitor.visitSingularBoolField(value: self.hasData_p, fieldNumber: 1)
    }
    if self.fileCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.fileCount, fieldNumber: 2)
    }
    if self.dirCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.dirCount, fieldNumber: 3)
    }
    if self.trashedFileCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.trashedFileCount, fieldNumber: 4)
    }
    if self.trashedDirCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.trashedDirCount, fieldNumber: 5)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.sizeBytes, fieldNumber: 6)
    }
    if self.trashedBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.trashedBytes, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_DirMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_DirMeta) -> Bool {
    if lhs.hasData_p != rhs.hasData_p {return false}
    if lhs.fileCount != rhs.fileCount {return false}
    if lhs.dirCount != rhs.dirCount {return false}
    if lhs.trashedFileCount != rhs.trashedFileCount {return false}
    if lhs.trashedDirCount != rhs.trashedDirCount {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.trashedBytes != rhs.trashedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContainerNodeMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dir_meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dirMeta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dirMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_ContainerNodeMeta) -> Bool {
    if lhs._dirMeta != rhs._dirMeta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CategoryNodeMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dir_meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dirMeta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dirMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_CategoryNodeMeta) -> Bool {
    if lhs._dirMeta != rhs._dirMeta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RootTypeNodeMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dir_meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dirMeta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dirMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_RootTypeNodeMeta) -> Bool {
    if lhs._dirMeta != rhs._dirMeta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalDirMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_uid"),
    2: .standard(proto: "is_live"),
    3: .standard(proto: "dir_meta"),
    5: .standard(proto: "all_children_fetched"),
    6: .standard(proto: "sync_ts"),
    7: .standard(proto: "create_ts"),
    8: .standard(proto: "modify_ts"),
    9: .standard(proto: "change_ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.parentUid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLive) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dirMeta) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allChildrenFetched) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.syncTs) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.createTs) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.modifyTs) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.changeTs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.parentUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.parentUid, fieldNumber: 1)
    }
    if self.isLive != false {
      try visitor.visitSingularBoolField(value: self.isLive, fieldNumber: 2)
    }
    try { if let v = self._dirMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.allChildrenFetched != false {
      try visitor.visitSingularBoolField(value: self.allChildrenFetched, fieldNumber: 5)
    }
    if self.syncTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.syncTs, fieldNumber: 6)
    }
    if self.createTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createTs, fieldNumber: 7)
    }
    if self.modifyTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.modifyTs, fieldNumber: 8)
    }
    if self.changeTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.changeTs, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_LocalDirMeta) -> Bool {
    if lhs.parentUid != rhs.parentUid {return false}
    if lhs.isLive != rhs.isLive {return false}
    if lhs._dirMeta != rhs._dirMeta {return false}
    if lhs.allChildrenFetched != rhs.allChildrenFetched {return false}
    if lhs.syncTs != rhs.syncTs {return false}
    if lhs.createTs != rhs.createTs {return false}
    if lhs.modifyTs != rhs.modifyTs {return false}
    if lhs.changeTs != rhs.changeTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalFileMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_uid"),
    2: .standard(proto: "is_live"),
    3: .standard(proto: "size_bytes"),
    4: .standard(proto: "sync_ts"),
    5: .standard(proto: "create_ts"),
    6: .standard(proto: "modify_ts"),
    7: .standard(proto: "change_ts"),
    8: .same(proto: "md5"),
    9: .same(proto: "sha256"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.parentUid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLive) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sizeBytes) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.syncTs) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.createTs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.modifyTs) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.changeTs) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.md5) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sha256) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parentUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.parentUid, fieldNumber: 1)
    }
    if self.isLive != false {
      try visitor.visitSingularBoolField(value: self.isLive, fieldNumber: 2)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.sizeBytes, fieldNumber: 3)
    }
    if self.syncTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.syncTs, fieldNumber: 4)
    }
    if self.createTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createTs, fieldNumber: 5)
    }
    if self.modifyTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.modifyTs, fieldNumber: 6)
    }
    if self.changeTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.changeTs, fieldNumber: 7)
    }
    if !self.md5.isEmpty {
      try visitor.visitSingularStringField(value: self.md5, fieldNumber: 8)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularStringField(value: self.sha256, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_LocalFileMeta) -> Bool {
    if lhs.parentUid != rhs.parentUid {return false}
    if lhs.isLive != rhs.isLive {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.syncTs != rhs.syncTs {return false}
    if lhs.createTs != rhs.createTs {return false}
    if lhs.modifyTs != rhs.modifyTs {return false}
    if lhs.changeTs != rhs.changeTs {return false}
    if lhs.md5 != rhs.md5 {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GDriveFileMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "goog_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "owner_uid"),
    4: .standard(proto: "shared_by_user_uid"),
    5: .standard(proto: "drive_id"),
    6: .standard(proto: "parent_uid_list"),
    7: .standard(proto: "sync_ts"),
    8: .standard(proto: "modify_ts"),
    9: .standard(proto: "create_ts"),
    10: .same(proto: "md5"),
    11: .same(proto: "version"),
    12: .standard(proto: "size_bytes"),
    13: .standard(proto: "mime_type_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.googID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.ownerUid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sharedByUserUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.driveID) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.parentUidList) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.syncTs) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.modifyTs) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.createTs) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.md5) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.sizeBytes) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.mimeTypeUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.googID.isEmpty {
      try visitor.visitSingularStringField(value: self.googID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.ownerUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.ownerUid, fieldNumber: 3)
    }
    if self.sharedByUserUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.sharedByUserUid, fieldNumber: 4)
    }
    if !self.driveID.isEmpty {
      try visitor.visitSingularStringField(value: self.driveID, fieldNumber: 5)
    }
    if !self.parentUidList.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.parentUidList, fieldNumber: 6)
    }
    if self.syncTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.syncTs, fieldNumber: 7)
    }
    if self.modifyTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.modifyTs, fieldNumber: 8)
    }
    if self.createTs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createTs, fieldNumber: 9)
    }
    if !self.md5.isEmpty {
      try visitor.visitSingularStringField(value: self.md5, fieldNumber: 10)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 11)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.sizeBytes, fieldNumber: 12)
    }
    if self.mimeTypeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.mimeTypeUid, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_GDriveFileMeta) -> Bool {
    if lhs.googID != rhs.googID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.ownerUid != rhs.ownerUid {return false}
    if lhs.sharedByUserUid != rhs.sharedByUserUid {return false}
    if lhs.driveID != rhs.driveID {return false}
    if lhs.parentUidList != rhs.parentUidList {return false}
    if lhs.syncTs != rhs.syncTs {return false}
    if lhs.modifyTs != rhs.modifyTs {return false}
    if lhs.createTs != rhs.createTs {return false}
    if lhs.md5 != rhs.md5 {return false}
    if lhs.version != rhs.version {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.mimeTypeUid != rhs.mimeTypeUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GDriveFolderMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "goog_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "owner_uid"),
    4: .standard(proto: "shared_by_user_uid"),
    5: .standard(proto: "drive_id"),
    6: .standard(proto: "parent_uid_list"),
    7: .standard(proto: "sync_ts"),
    8: .standard(proto: "modify_ts"),
    9: .standard(proto: "create_ts"),
    10: .standard(proto: "dir_meta"),
    11: .standard(proto: "all_children_fetched"),
  ]

  fileprivate class _StorageClass {
    var _googID: String = String()
    var _name: String = String()
    var _ownerUid: UInt32 = 0
    var _sharedByUserUid: UInt32 = 0
    var _driveID: String = String()
    var _parentUidList: [UInt32] = []
    var _syncTs: UInt64 = 0
    var _modifyTs: UInt64 = 0
    var _createTs: UInt64 = 0
    var _dirMeta: Outlet_Backend_Agent_Grpc_Generated_DirMeta? = nil
    var _allChildrenFetched: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _googID = source._googID
      _name = source._name
      _ownerUid = source._ownerUid
      _sharedByUserUid = source._sharedByUserUid
      _driveID = source._driveID
      _parentUidList = source._parentUidList
      _syncTs = source._syncTs
      _modifyTs = source._modifyTs
      _createTs = source._createTs
      _dirMeta = source._dirMeta
      _allChildrenFetched = source._allChildrenFetched
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._googID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._ownerUid) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._sharedByUserUid) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._driveID) }()
        case 6: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._parentUidList) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._syncTs) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._modifyTs) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._createTs) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dirMeta) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._allChildrenFetched) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._googID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._googID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._ownerUid != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ownerUid, fieldNumber: 3)
      }
      if _storage._sharedByUserUid != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sharedByUserUid, fieldNumber: 4)
      }
      if !_storage._driveID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._driveID, fieldNumber: 5)
      }
      if !_storage._parentUidList.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._parentUidList, fieldNumber: 6)
      }
      if _storage._syncTs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._syncTs, fieldNumber: 7)
      }
      if _storage._modifyTs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._modifyTs, fieldNumber: 8)
      }
      if _storage._createTs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._createTs, fieldNumber: 9)
      }
      try { if let v = _storage._dirMeta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._allChildrenFetched != false {
        try visitor.visitSingularBoolField(value: _storage._allChildrenFetched, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_GDriveFolderMeta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._googID != rhs_storage._googID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._ownerUid != rhs_storage._ownerUid {return false}
        if _storage._sharedByUserUid != rhs_storage._sharedByUserUid {return false}
        if _storage._driveID != rhs_storage._driveID {return false}
        if _storage._parentUidList != rhs_storage._parentUidList {return false}
        if _storage._syncTs != rhs_storage._syncTs {return false}
        if _storage._modifyTs != rhs_storage._modifyTs {return false}
        if _storage._createTs != rhs_storage._createTs {return false}
        if _storage._dirMeta != rhs_storage._dirMeta {return false}
        if _storage._allChildrenFetched != rhs_storage._allChildrenFetched {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NonexistentDirMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta, rhs: Outlet_Backend_Agent_Grpc_Generated_NonexistentDirMeta) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
